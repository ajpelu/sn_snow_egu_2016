---
title: "Explore raw values of snow-cover indicators"
author: "AJ Perez-Luque (@ajpelu); FJ Bonet; J Herrero and R. Perez-Perez"
date: "2016 March"
output:  
    md_document:
      variant: markdown_github
---

```{r metadata, echo=FALSE}
# Set working directory 

machine <- 'ajpelu'
# machine <- 'ajpeluLap'
di <- paste('/Users/', machine, '/Dropbox/MS/CONGRESO_EGU2016/sn_snow_egu_2016', sep='')

```

```{r packages, warning=FALSE, message=FALSE}
# Load packages 
library("raster")
library("rgdal")
library("sp")
library("dplyr")
```

## Prepare Data

* Read snow cover indicator data and subset snow cover duration 
* Read topographic data and position (spatial) data

```{r}
# Read data (snow cover)
snow <- read.csv(file=paste(di, "/data/raw/snow_sn.csv", sep= ""), header = TRUE) 
# --   

# Read spatial data and Get lat/long
centroides <- rgdal::readOGR(dsn=paste(di, "/data/geoinfo", sep=""),
                             layer = "centroides_selected", verbose = FALSE)
# Select only attributes of interest and rename them
centroides <- centroides[c("id")]

# Create lat/lng by id 
xycentroides <- cbind(centroides@data, coordinates(centroides))
names(xycentroides) <- c("nie_malla_modi_id", "lon","lat")

xycentroides <- filter(xycentroides, nie_malla_modi_id %in% snow$nie_malla_modi_id)

# -- 

# Read Topographic data 
rawtopo <- read.csv(file=paste(di, "/data/topo_nie_malla_modis.csv", sep=""),
                 header=TRUE,
                 sep = ",") 
# function to convert radian to degree 
rad2deg <- function(rad) {(rad * 180) / (pi)} 


topo <- rawtopo %>% 
  filter(id %in% snow$nie_malla_modi_id) %>% 
  mutate(nie_malla_modi_id = id, 
         slope50mean_deg = rad2deg(slope50mean),
         slope50median_deg = rad2deg(slope50median),
         aspect50mean_deg = rad2deg(aspect50mean),
         aspect50median_deg = rad2deg(aspect50median)) %>%
  dplyr::select(nie_malla_modi_id, dem50mean, dem50median, slope50mean_deg, 
         slope50median_deg, aspect50mean_deg, aspect50median_deg) 
# -- 


# Create a dataframe with all variables for SCD 
scd <- snow %>% 
  dplyr::select(nie_malla_modi_id, ano, scd) %>% 
  inner_join(topo, by="nie_malla_modi_id") %>%
  inner_join(xycentroides, by="nie_malla_modi_id") 


scd1900 <- scd %>% filter(dem50mean > 1900) 


m1 <- glm(scd ~ ano + dem50mean + slope50mean_deg + aspect50mean_deg + lon + lat,
          data=scd1900, family="poisson")

e1 <- resid(m2, type = 'pearson')
n <- nrow(scd1900) 
p <- length(coef(m2))
sum(e1^2) /(n-p)



scd_df <- snow %>%
  dplyr::select(nie_malla_modi_id, ano, scd) %>%
  mutate(year = ano) %>% 
  group_by(nie_malla_modi_id) %>% 
  summarise(mean = mean(scd),
            sd = sd(scd),
            cv = raster::cv(scd),
            se = sd / sqrt (length(scd)))
            
library('MASS')

m2 <- glm.nb(scd ~ ano + dem50mean + slope50mean_deg + aspect50mean_deg + lon + lat,
          data=scd1900)

drop1(m2, test="Chi")





plot(x = scd1900$slope50mean_deg, y = scd1900$scd, type='n')

mnd <- expand.grid(dem50mean=0, 
                   ano=2000,
                   slope50mean_deg=seq(0,50,by=1),
                   aspect50mean_deg=0, 
                   lon=-3.60,
                   lat=36.9)
                   



p1 <- predict(m2, newdata = mnd, type ='link', se=TRUE)
lines(x = mnd$slope50mean_deg, y=p1$fit)


newdata2 <- data.frame(
  math = rep(seq(from = min(dat$math), to = max(dat$math), length.out = 100), 3),
  prog = factor(rep(1:3, each = 100), levels = 1:3, labels =
  levels(dat$prog)))

newdata2 <- cbind(newdata2, predict(m1, newdata2, type = "link", se.fit=TRUE))
newdata2 <- within(newdata2, {
  DaysAbsent <- exp(fit)
  LL <- exp(fit - 1.96 * se.fit)
  UL <- exp(fit + 1.96 * se.fit)
})

ggplot(newdata2, aes(math, DaysAbsent)) +
  geom_ribbon(aes(ymin = LL, ymax = UL, fill = prog), alpha = .25) +
  geom_line(aes(colour = prog), size = 2) +
  labs(x = "Math Score", y = "Predicted Days Absent")
                       
                       
                       





names(snow_sn)[3] <- "year"

```

A continuación creamos un bucle para obtener de cada indicador la tendencia y la pendiente. Aplicamos la técnica de Mann-Kendall-Theil-Sen. El bucle realiza las siguientes operaciones: 

* Crea una variable con los indicadores para el bucle. 
* Realiza un subset de datos con los valores del indicador para cada pixel. Obtenemos una serie de datos por cada pixel. 
* Calculamos la tendencia y la pendiente
* Guardamos los resultamos como csv (uno por cada indicador, ver `./data/derived/`)

```{r}
# Loop to compute the MKT by indicator

# Define name of indicators (see variables names)
indicadores <- c("scd", "scod", "scmd", "scmc", "pre", "pre_snow", "pre_snow_per", "temp")

# subset by indicator
for (j in indicadores){ 
  # Create a subset by indicator
  subdf <- mydf[, names(mydf) %in% c("nie_malla_modi_id", "year", j )]
  
  # Manipule data. Transpose 
  # la funcion aggregate es porque tenemos duplicados 
  aux <- dcast(subdf, year ~ nie_malla_modi_id, value.var = j, fun.aggregate = mean) 

  # Create a zoo object 
  auxts <- zoo(aux[-1],aux[,1])
  
  # Compute Mann Kendall and Theil 
  theil <- mannKen(as.ts(auxts))
  
  # Prepare data output
  theil <- as.data.frame(theil)
  
  theil_df <- theil %>% 
    mutate(nie_malla_modi_id = as.numeric(rownames(theil))) %>%
    mutate(sen_slope = round(sen.slope, 3),
           sen_slope_per = round(sen.slope.pct, 2),
           p_value = round(p.value, 5),
           tau = round(tau, 3)) %>%
    dplyr::select(nie_malla_modi_id, sen_slope, sen_slope_per, p_value, tau)
  
  # As data.frame
  theil_df <- as.data.frame(theil_df)
  
  # Rename variables adding dataframe name
  
  # Create vector of new names 
  new_names <- c(paste(names(theil_df), j ,sep='_'))
  
  theil_rename <- theil_df %>% rename_(.dots = setNames(names(.), new_names)) %>%
    dplyr::select(nie_malla_modi_id = starts_with("nie_malla_modi_id"), everything())
  
  # Write table 
  write.table(assign(j, theil_rename), file=paste(di, "/data/derived/", j, ".csv", sep=""), row.names=FALSE, sep=',')
  
  # Check Results. Get the pixel with NA in pvalue. Save results
  aux_na <- theil_df[!complete.cases(theil_df),]
  aux_na$var <- rep(j,nrow(aux_na))
  write.table(aux_na[,c("nie_malla_modi_id","var")], file=paste(di, "/data/derived/na_", j, ".csv", sep=""), row.names=FALSE, sep=',')
} 
```




